"""
typhoon_sim.py
A simple typhoon (vortex) wind-field simulation + animation using numpy and matplotlib.

Run:
    python typhoon_sim.py

Controls:
- Edit the vortices list to add/remove storms or change strength/position.
- Press the plot window's close button to stop.
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

# ---------- Simulation parameters ----------
# domain (longitude, latitude) in degrees
lon_min, lon_max = 100, 160
lat_min, lat_max = -10, 30
nx, ny = 160, 120          # grid resolution (increase for smoother output)
dt = 0.08                  # animation time step (affects how fast streamlines advect)
n_frames = 800             # number of frames in the animation (or use blit for continuous)

# background (large-scale) flow (u: eastward, v: northward)
BACKGROUND_U = 2.0         # positive -> wind from west to east
BACKGROUND_V = -0.5        # positive -> wind from south to north

# Vortex (typhoon) definition
# Each vortex is a dict with:
#  - lon, lat : center position in degrees
#  - strength : positive for counterclockwise (northern-hemisphere cyclone),
#               negative for clockwise
#  - radius   : scale radius (degrees) where max rotation occurs
#  - decay    : how fast the vortex influence decays outward
vortices = [
    {"lon": 120.5, "lat": 18.0, "strength": 5500.0, "radius": 3.5, "decay": 0.9},
    {"lon": 145.0, "lat": 15.0, "strength": 4200.0, "radius": 4.0, "decay": 0.9},
    # add more vortices here if you like
]

# ---------- Helper functions ----------
def deg2rad(x):
    return (x / 180.0) * np.pi

def vortex_wind(lon, lat, vc):
    """
    Compute (u,v) wind contribution from a simplified point vortex model.
    lon, lat: arrays in degrees
    vc: vortex config dict
    Returns arrays (u_contrib, v_contrib) same shape as lon/lat
    """
    # convert degree offsets (approx equal-area for small domains)
    dx = (lon - vc["lon"])
    dy = (lat - vc["lat"])
    # distance (in degrees)
    r = np.sqrt(dx * dx + dy * dy) + 1e-6

    # tangential wind profile: V_t = strength * (r / radius) * exp(-decay*(r/radius))
    # This creates a max near r ~ radius and decays outward
    rr = r / vc["radius"]
    Vt = vc["strength"] * rr * np.exp(-vc["decay"] * rr)

    # Convert tangential speed to vector components:
    # unit tangential is (-dy/r, dx/r) for counterclockwise rotation when strength>0
    u_t = -dy / r * Vt
    v_t =  dx / r * Vt

    # If strength is negative, rotation flips automatically since Vt uses sign of strength
    return u_t, v_t

def compute_wind_field(lons, lats):
    """Compute combined wind field (u,v) from background + all vortices."""
    u = np.full_like(lons, BACKGROUND_U, dtype=float)
    v = np.full_like(lats, BACKGROUND_V, dtype=float)

    for vc in vortices:
        u_t, v_t = vortex_wind(lons, lats, vc)
        u += u_t
        v += v_t

    return u, v

# ---------- Build grid ----------
lons = np.linspace(lon_min, lon_max, nx)
lats = np.linspace(lat_min, lat_max, ny)
lon_grid, lat_grid = np.meshgrid(lons, lats)

# compute magnitude for coloring
u0, v0 = compute_wind_field(lon_grid, lat_grid)
speed0 = np.sqrt(u0**2 + v0**2)

# ---------- Plot & animation ----------
fig, ax = plt.subplots(figsize=(11,6))
ax.set_title("Typhoon / Vortex Wind Field Simulation")
ax.set_xlabel("Longitude")
ax.set_ylabel("Latitude")
ax.set_xlim(lon_min, lon_max)
ax.set_ylim(lat_min, lat_max)
ax.set_aspect('auto')

# background magnitude image
mag_im = ax.imshow(speed0, origin='lower',
                   extent=(lon_min, lon_max, lat_min, lat_max),
                   alpha=0.9, cmap='viridis')  # colormap shows speed

# streamplot for wind: we'll create initial streamlines
strm = ax.streamplot(lon_grid, lat_grid, u0, v0, density=1.3, linewidth=1.0, arrowsize=1.5)

# draw vortex centers
for vc in vortices:
    ax.plot(vc["lon"], vc["lat"], 'o', markersize=8, markeredgecolor='k', markerfacecolor='none')

# animation update function: allow small movement of vortices for realism
def update(frame):
    # simple translation of vortices (make them slowly move east-northeast)
    for i, vc in enumerate(vortices):
        # a simple drift pattern — you can replace this with any track data
        vc["lon"] += 0.01 + 0.005 * np.sin(frame * 0.02 + i)
        vc["lat"] += 0.002 * np.cos(frame * 0.013 + i)

    u, v = compute_wind_field(lon_grid, lat_grid)
    speed = np.sqrt(u**2 + v**2)

    # update background magnitude image
    mag_im.set_data(speed)

    # remove old streamlines and draw new ones
    for coll in getattr(update, "collections", []):
        coll.remove()
    update.collections = []

    # draw new streamplot and store the returned LineCollections so we can remove them next frame
    # Matplotlib's streamplot returns a StreamplotSet containing lines and arrows as collections
    s = ax.streamplot(lon_grid, lat_grid, u, v, density=1.3, linewidth=1.0, arrowsize=1.5)
    # collect the artist collections so we can remove them later
    if hasattr(s, 'lines'):
        update.collections += [s.lines]
    if hasattr(s, 'arrows'):
        update.collections += [s.arrows]

    # update title with frame/time
    ax.set_title(f"Typhoon simulation — frame {frame}")

    return [mag_im] + update.collections

# init attribute
update.collections = []

anim = FuncAnimation(fig, update, frames=n_frames, interval=30, blit=False)

plt.tight_layout()
plt.show()
